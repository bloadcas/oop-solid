
Claro, aquí tienes 10 ejercicios con enunciados detallados donde se aplican uno o más principios SOLID. Los enunciados están diseñados para que puedas imaginar el diagrama de clases fácilmente y aplicar los principios SOLID de manera práctica.

---

### 1. **Aplicar el Principio de Responsabilidad Única (SRP)**
   **Enunciado:**
   Tienes una clase llamada `Empleado` que gestiona tanto los datos personales como el cálculo del salario de los empleados. La clase también incluye un método para generar un informe con el resumen del salario y los beneficios. Refactoriza esta clase para aplicar el Principio de Responsabilidad Única (SRP).  
   
   Crea las siguientes clases:
   - **Empleado**: Contendrá únicamente los datos personales (nombre, puesto, etc.).
   - **CalculadoraSalario**: Se encargará de calcular el salario de un empleado basado en su puesto y horas trabajadas.
   - **GeneradorInformes**: Se encargará de generar el informe de salario para el empleado.

   **Objetivo:** Asegúrate de que cada clase tenga una única responsabilidad, delegando tareas adecuadamente.

---

### 2. **Aplicar el Principio de Abierto/Cerrado (OCP)**
   **Enunciado:**
   Estás desarrollando un sistema de cálculo de impuestos para diferentes tipos de productos. Actualmente, la clase `CalculadoraImpuestos` tiene un método `calcularImpuesto` que aplica un cálculo fijo a todos los productos. Sin embargo, la legislación cambia y debes incorporar nuevos tipos de impuestos según el tipo de producto (por ejemplo, libros, alimentos y electrónicos).  
   
   Crea las siguientes clases:
   - **Producto**: Contendrá atributos como el nombre y el precio.
   - **CalculadoraImpuestos**: Tendrá un método `calcularImpuesto(Producto producto)` que debe ser capaz de calcular el impuesto para diferentes tipos de productos. Esta clase debe estar abierta a extensión, pero cerrada a modificación.
   - **ImpuestoElectronicos**, **ImpuestoLibros**, **ImpuestoAlimentos**: Clases que implementan la lógica de cálculo de impuestos para cada tipo de producto.

   **Objetivo:** Utiliza la herencia o interfaces para permitir la extensión de la clase `CalculadoraImpuestos` sin modificar su código original.

---

### 3. **Aplicar el Principio de Sustitución de Liskov (LSP)**
   **Enunciado:**
   Tienes una jerarquía de clases donde `Empleado` es la clase base y `EmpleadoTiempoCompleto` y `EmpleadoMedioTiempo` son subclases. La clase `Empleado` tiene un método `calcularSalario` que, en la subclase `EmpleadoMedioTiempo`, solo devuelve una fracción del salario. Sin embargo, al usar una instancia de `EmpleadoMedioTiempo` donde se espera un `Empleado`, el programa lanza un error.  
   
   Crea las siguientes clases:
   - **Empleado**: Contendrá el nombre y el salario base, y un método `calcularSalario()`.
   - **EmpleadoTiempoCompleto**: Sobrescribe `calcularSalario()` para calcular el salario completo.
   - **EmpleadoMedioTiempo**: Sobrescribe `calcularSalario()` para calcular el salario proporcional.

   **Objetivo:** Asegúrate de que las subclases mantengan la coherencia del comportamiento de la clase base, sin causar errores en el código cliente al intercambiar `Empleado` por sus subclases.

---

### 4. **Aplicar el Principio de Segregación de Interfaces (ISP)**
   **Enunciado:**
   Estás desarrollando un sistema de gestión para vehículos. La interfaz `Vehiculo` tiene métodos como `arrancar()`, `detener()`, `navegar()` y `volar()`. Sin embargo, un coche solo necesita los métodos `arrancar()` y `detener()`, mientras que un avión necesita los métodos `arrancar()`, `detener()` y `volar()`.  
   
   Crea las siguientes interfaces:
   - **IVehiculo**: Una interfaz común con los métodos `arrancar()` y `detener()`.
   - **INavegable**: Una interfaz con el método `navegar()`.
   - **IVolable**: Una interfaz con el método `volar()`.
   - **Coche**: Implementará solo `IVehiculo`.
   - **Avion**: Implementará `IVehiculo`, `INavegable`, y `IVolable`.

   **Objetivo:** Asegúrate de que las clases no implementen métodos que no necesiten, siguiendo el Principio de Segregación de Interfaces.

---

### 5. **Aplicar el Principio de Inversión de Dependencias (DIP)**
   **Enunciado:**
   Tienes una clase `Pedido` que depende directamente de la clase `ServicioEnvio` para calcular los costos de envío y gestionar el proceso de envío. Esta dependencia está provocando que la clase `Pedido` sea difícil de mantener y extender. Refactoriza el código para aplicar el Principio de Inversión de Dependencias (DIP).

   Crea las siguientes clases:
   - **Pedido**: Tendrá un método `calcularCostoEnvio()` que dependerá de una interfaz `IServicioEnvio`.
   - **ServicioEnvioDHL** y **ServicioEnvioFedEx**: Implementarán la interfaz `IServicioEnvio` con la lógica de cálculo de costos y envío.

   **Objetivo:** Utiliza interfaces para invertir las dependencias entre `Pedido` y las clases de servicios de envío, asegurando que las implementaciones puedan cambiar sin modificar la clase `Pedido`.

---

### 6. **Aplicar el Principio de Responsabilidad Única (SRP) y Abierto/Cerrado (OCP)**
   **Enunciado:**
   Tienes una clase `Factura` que calcula y genera la factura de un cliente, pero esta clase también tiene la responsabilidad de aplicar descuentos y gestionar promociones. Refactoriza la clase para que sea más fácil agregar nuevos tipos de descuentos y promociones sin modificar la clase `Factura`.  
   
   Crea las siguientes clases:
   - **Factura**: Contendrá los métodos para agregar productos y generar la factura.
   - **CalculadoraDescuento**: Implementará diferentes tipos de descuentos (descuento por volumen, por temporada, etc.).
   - **Promocion**: Será una clase base o interfaz para aplicar promociones.
   - **PromocionDescuento** y **PromocionRegalo**: Implementarán tipos concretos de promociones.

   **Objetivo:** Asegúrate de que la clase `Factura` esté abierta a extensión, pero cerrada a modificación.

---

### 7. **Aplicar el Principio de Sustitución de Liskov (LSP) y Segregación de Interfaces (ISP)**
   **Enunciado:**
   Tienes una jerarquía de clases de `Empleado` con distintos tipos de empleados (por ejemplo, `EmpleadoTiempoCompleto` y `EmpleadoPorHoras`). Los empleados a tiempo completo reciben un salario fijo, pero los empleados por horas tienen un salario variable basado en las horas trabajadas. Refactoriza para aplicar LSP e ISP.

   Crea las siguientes interfaces y clases:
   - **Empleado**: Contendrá el nombre y un salario base, y un método `calcularSalario()`.
   - **EmpleadoTiempoCompleto**: Implementará `calcularSalario()` para el cálculo de salario fijo.
   - **EmpleadoPorHoras**: Implementará `calcularSalario()` según el número de horas trabajadas.
   - **EmpleadoFreelance**: Implementará una interfaz `IFreelance` que gestione las horas y el pago por hora.

   **Objetivo:** Mantén las clases coherentes con LSP, y asegúrate de que las interfaces no incluyan métodos innecesarios.

---

### 8. **Aplicar el Principio de Responsabilidad Única (SRP) y Abierto/Cerrado (OCP)**
   **Enunciado:**
   Tienes una clase `GestorDePedidos` que gestiona la creación y el envío de pedidos, pero también realiza el cálculo del total de un pedido y las validaciones. Refactoriza esta clase para que las responsabilidades estén bien separadas y para que sea fácil agregar nuevas validaciones o nuevas formas de calcular el total sin modificar la clase `GestorDePedidos`.

   Crea las siguientes clases:
   - **Pedido**: Contendrá información sobre los productos y el total.
   - **GestorDePedidos**: Se encargará de procesar el pedido y delegará el cálculo del total a una clase `CalculadorTotal`.
   - **CalculadorTotal**: Implementará un método para calcular el total de un pedido.
   - **ValidadorPedido**: Se encargará de realizar las validaciones del pedido.

   **Objetivo:** Aplica SRP para separar las responsabilidades y OCP para permitir la extensión sin modificar el código.

---

### 9. **Aplicar el Principio de Inversión de Dependencias (DIP)**
   **Enunciado:**
   Tienes una clase `AlertaSistema` que depende directamente de la clase `EmailService` para enviar notificaciones por correo electrónico. Refactoriza el sistema para que las dependencias estén invertidas.

   Crea las siguientes clases:
   - **AlertaSistema**: Contendrá un método `enviarAlerta()` y dependerá de una interfaz `Notificador`.
   - **Notificador**: Una interfaz con un método `enviar()`.
   - **EmailService**: Implementará `Notificador` para enviar alertas por correo electrónico.
   - **SMSService**: Implementará `Notificador` para enviar alertas por mensaje de texto.

   **Objetivo:** Asegúrate de que `AlertaSistema` no dependa de clases concretas, sino de interfaces, lo que facilita cambiar la implementación sin modificar la clase.

---

### 10. **Aplicar el Principio de Abierto/Cerrado (OCP) y Responsabilidad Única (SRP)**
   **Enunciado:**
   Tienes una clase `SistemaDeNotificaciones` que envía notificaciones a los usuarios. Actualmente, la clase tiene métodos para enviar notificaciones por correo electrónico, SMS y notificaciones push. Refactoriza para aplicar OCP y SRP.

   Crea las siguientes clases:
   - **Notificador**: Una interfaz que tendrá el método `enviarNotificacion()`.
   - **CorreoElectronico**, **SMS**, **PushNotification**: Implementarán la interfaz `Notificador` para enviar notificaciones a través de diferentes canales.
   - **SistemaDeNotificaciones**: Se encargará de manejar las notificaciones, delegando el envío a las implementaciones de `Notificador`.

   **Objetivo:** Asegúrate de que el sistema esté abierto a la adición de nuevos tipos de notificación, pero cerrado a la modificación.

---

Espero que estos ejercicios sean útiles para practicar los principios SOLID en Java. Si tienes dudas sobre cómo implementarlos o necesitas ayuda, no dudes en preguntar.